import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

import '../../../../../objectbox.dart';
import '../../../../models/data/entry.dart';
import '../../../../models/metadata/entry.dart';
import '../../../../models/metadata/program_rule.dart';
import '../../../../repositories/data/entry.dart';
import '../../../../repositories/metadata/entry.dart';
import '../../../../utils/entry.dart';
import '../form_state.dart';
import 'program_rule_engine_state.dart';

/// This is a controller class for managing enrollment form operations.
///
/// This class extends [D2FormController] and includes functionality for handling
/// program rule engine states related to enrollment forms.
class D2TrackerEnrollmentFormController extends D2FormController
    with ProgramRuleEngineState {
  /// The program associated with the enrollment.
  D2Program program;

  /// The enrollment instance being managed (optional).
  D2Enrollment? enrollment;

  /// The tracked entity instance associated with the enrollment (optional).
  D2TrackedEntity? trackedEntity;

  @override
  D2ObjectBox db;

  /// The organisation unit UID for the enrollment.
  String orgUnit;

  /// List of reserved values used in the form.
  List<D2ReservedValue> reservedValues = [];

  @override
  late D2ProgramRuleEngine programRuleEngine;

  /// Checks if the form is in edit mode (i.e., a tracked entity is selected).
  bool get editMode {
    return trackedEntity != null;
  }

  /// Constructs a new [D2TrackerEnrollmentFormController].
  ///
  /// - [db] The database instance.
  /// - [program] The program associated with the enrollment.
  /// - [orgUnit] The organisation unit UID for the enrollment.
  /// - [trackedEntity] The tracked entity associated with the enrollment (optional).
  /// - [enrollment] The enrollment instance being managed (optional).
  D2TrackerEnrollmentFormController(
      {required this.db,
      required this.program,
      required this.orgUnit,
      this.trackedEntity,
      this.enrollment,
      super.mandatoryFields,
      super.disabledFields,
      super.hiddenFields,
      super.hiddenSections,
      super.formFields,
      super.initialValues}) {
    if (trackedEntity != null) {
      List<D2TrackedEntityAttributeValue> attributes =
          trackedEntity!.getAttributesByProgram(program);
      Map<String, dynamic> formValues = {};

      for (D2TrackedEntityAttributeValue element in attributes) {
        formValues.addAll(element.toFormValues());
      }
      //Get the enrollment from here
      if (enrollment == null) {
        D2Enrollment? derivedEnrollment = trackedEntity!.enrollments
            .firstWhereOrNull((element) =>
                element.program.targetId == program.id &&
                element.status == "ACTIVE");

        enrollment = derivedEnrollment;
        if (kDebugMode) {
          print(
              "The selected tracked entity does not have an active enrollment in this program. A new enrollment will be created instead");
        }
      } else {
        Map<String, dynamic> enrollmentFormValues = enrollment!.toFormValues();
        formValues.addAll(enrollmentFormValues);
      }
      setValues(formValues);
    }
    getMandatoryFields();
    initializeProgramRuleEngine(program, trackedEntity);
    disableAutoGeneratedFields();
    if (!editMode) {
      getAutoGeneratedValues();
    }
  }

  /// Initializes the program rule engine with program rules and variables.
  void initializeProgramRuleEngine(
    D2Program program,
    D2TrackedEntity? trackedEntity,
  ) {
    List<D2ProgramRule> programRules = program.programRules;
    List<D2ProgramRuleVariable> programRuleVariables =
        program.programRuleVariables;
    programRuleEngine = D2ProgramRuleEngine(
      programRules: programRules,
      programRuleVariables: programRuleVariables,
      trackedEntity: trackedEntity,
    );

    runProgramRules();
  }

  /// Disables auto-generated fields based on program tracked entity attributes.
  disableAutoGeneratedFields() {
    List<D2ProgramTrackedEntityAttribute> autogeneratedAttributes = program
        .programTrackedEntityAttributes
        .where((D2ProgramTrackedEntityAttribute pAttribute) =>
            pAttribute.trackedEntityAttribute.target!.generated ?? false)
        .toList();
    List<String> fieldsToDisable = autogeneratedAttributes
        .map((e) => e.trackedEntityAttribute.target!.uid)
        .toList();

    disableFields(fieldsToDisable);
  }

  /// Retrieves auto-generated values based on program tracked entity attributes.
  getAutoGeneratedValues() {
    List<D2ProgramTrackedEntityAttribute> autogeneratedAttributes = program
        .programTrackedEntityAttributes
        .where((D2ProgramTrackedEntityAttribute pAttribute) =>
            pAttribute.trackedEntityAttribute.target!.generated ?? false)
        .toList();

    Map<String, dynamic> values = {};

    D2OrgUnit? orgUnit = D2OrgUnitRepository(db).getByUid(this.orgUnit);

    for (D2ProgramTrackedEntityAttribute pAttribute
        in autogeneratedAttributes) {
      String attributeId = pAttribute.trackedEntityAttribute.target!.uid;
      D2ReservedValue? reservedValue = D2ReservedValueRepository(db)
          .getReservedValue(owner: pAttribute, orgUnit: orgUnit!);
      if (reservedValue != null) {
        values.addAll({attributeId: reservedValue.value});
        reservedValues.add(reservedValue);
      } else {
        setError(attributeId,
            "Could not auto fill this field. Please make sure you have required reserved values");
      }
    }

    setValues(values);
  }

  /// Retrieves mandatory fields from program tracked entity attributes.
  getMandatoryFields() {
    List<String> mandatoryFields = program.programTrackedEntityAttributes
        .where((pAttribute) => pAttribute.mandatory)
        .map((pAttribute) => pAttribute.trackedEntityAttribute.target!.uid)
        .toList();
    this.mandatoryFields.addAll(mandatoryFields);
  }

  /// Updates reserved values and marks them as assigned.
  updateReservedValues() {
    for (D2ReservedValue value in reservedValues) {
      value.setAssigned();
    }
    D2ReservedValueRepository(db).saveEntities(reservedValues);
  }

  /// Creates a new enrollment based on the form data.
  ///
  /// Returns the created [D2Enrollment] entity.
  Future<D2Enrollment> create() async {
    Map<String, dynamic> validatedFormValues = submit();
    D2OrgUnit? orgUnit = D2OrgUnitRepository(db).getByUid(this.orgUnit);
    if (orgUnit == null) {
      throw "Could not get entity's organisation unit. You either have to pass it as a parameter when initializing the controller or have a required field with key 'orgUnit'";
    }
    D2TrackedEntity trackedEntity = D2TrackedEntity.fromFormValues(
        validatedFormValues,
        db: db,
        program: program,
        orgUnit: orgUnit);
    trackedEntity.save(db);
    updateReservedValues();
    return trackedEntity.enrollments.first;
  }

  /// Updates an existing enrollment based on the form data.
  ///
  /// Returns the updated enrollment.
  Future<D2Enrollment> update() async {
    if (trackedEntity == null) {
      throw "Invalid update call. Only call update if a default trackedEntity has been passed as a parameter when initializing the controller";
    }
    Map<String, dynamic> validatedFormValues = submit();
    D2OrgUnit? orgUnit = D2OrgUnitRepository(db).getByUid(this.orgUnit);
    trackedEntity!
        .updateFromFormValues(validatedFormValues, db: db, program: program);

    if (enrollment != null) {
      enrollment!
          .updateFromFormValues(validatedFormValues, db: db, program: program);
      enrollment!.save(db);
    } else {
      if (orgUnit == null) {
        throw "Could not get entity's organisation unit. You have to pass it as a parameter when initializing the controller.";
      }
      D2Enrollment enrollment = D2Enrollment.fromFormValues(validatedFormValues,
          db: db,
          trackedEntity: trackedEntity!,
          program: program,
          orgUnit: orgUnit);

      trackedEntity!.enrollments.add(enrollment);
      this.enrollment = enrollment;
    }
    trackedEntity!.save(db);
    return enrollment!;
  }

  /// Calls either [update] or [create] based on whether a tracked entity is selected.
  ///
  /// Returns the created or updated [D2Enrollment] entity.
  Future<D2Enrollment> save() async {
    if (trackedEntity != null) {
      return update();
    } else {
      return create();
    }
  }
}
